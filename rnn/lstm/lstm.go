package lstm

import (
	"math"
	"math/rand"

	"github.com/unixpickle/num-analysis/linalg"
)

// LSTMOutput stores all of the information
// generated by an LSTM during forward prop.
type LSTMOutput struct {
	NewState    linalg.Vector
	OutputMask  linalg.Vector
	MaskedState linalg.Vector

	MemInput  linalg.Vector
	InputMask linalg.Vector

	RememberMask linalg.Vector
}

// LSTM stores the parameters of a
// Long Short-Term Memory layer.
type LSTM struct {
	// The columns in these matrices correspond
	// first to inputs, then to the last state.
	// The rows correspond to different neurons
	// in the hidden (state) layer.
	InWeights *linalg.Matrix
	InGate    *linalg.Matrix
	RemGate   *linalg.Matrix
	OutGate   *linalg.Matrix

	// Each element of these vectors corresponds
	// to one hidden gated neuron.
	InBiases      linalg.Vector
	InGateBiases  linalg.Vector
	RemGateBiases linalg.Vector
	OutGateBiases linalg.Vector

	InputSize int
	StateSize int
}

func NewLSTM(inputSize, stateSize int) *LSTM {
	return &LSTM{
		InWeights: linalg.NewMatrix(stateSize, inputSize+stateSize),
		InGate:    linalg.NewMatrix(stateSize, inputSize+stateSize),
		RemGate:   linalg.NewMatrix(stateSize, inputSize+stateSize),
		OutGate:   linalg.NewMatrix(stateSize, inputSize+stateSize),

		InBiases:      make(linalg.Vector, stateSize),
		InGateBiases:  make(linalg.Vector, stateSize),
		RemGateBiases: make(linalg.Vector, stateSize),
		OutGateBiases: make(linalg.Vector, stateSize),

		InputSize: inputSize,
		StateSize: stateSize,
	}
}

// Randomize randomizes the weights in this LSTM
// unit to break symmetry.
func (l *LSTM) Randomize() {
	for _, mat := range []*linalg.Matrix{l.InWeights, l.InGate, l.RemGate, l.OutGate} {
		weightCoeff := math.Sqrt(3.0 / float64(mat.Cols))
		for i := range mat.Data {
			mat.Data[i] = (rand.Float64()*2 - 1) * weightCoeff
		}
	}
}

// PropagateForward takes a state and an input and
// runs them through an LSTM layer.
func (l *LSTM) PropagateForward(state, input linalg.Vector) *LSTMOutput {
	var res LSTMOutput

	augInSize := len(state) + len(input)
	inputMat := &linalg.Matrix{
		Rows: augInSize,
		Cols: 1,
		Data: make([]float64, augInSize),
	}
	copy(inputMat.Data, input)
	copy(inputMat.Data[len(input):], state)

	res.MemInput = linalg.Vector(l.InWeights.MulFast(inputMat).Data).Add(l.InBiases)
	res.InputMask = linalg.Vector(l.InGate.MulFast(inputMat).Data).Add(l.InGateBiases)
	res.RememberMask = linalg.Vector(l.RemGate.MulFast(inputMat).Data).Add(l.RemGateBiases)
	res.OutputMask = linalg.Vector(l.OutGate.MulFast(inputMat).Data).Add(l.OutGateBiases)

	sigmoidAll(res.MemInput, res.InputMask, res.RememberMask, res.OutputMask)
	maskedInput := piecewiseMul(res.MemInput, res.InputMask)

	maskedOldState := piecewiseMul(state, res.RememberMask)
	res.NewState = maskedOldState.Copy().Add(maskedInput)
	res.MaskedState = piecewiseMul(res.NewState, res.OutputMask)

	return &res
}

func piecewiseMul(v1, v2 linalg.Vector) linalg.Vector {
	res := make(linalg.Vector, len(v1))
	for i, x := range v1 {
		res[i] = x * v2[i]
	}
	return res
}

func sigmoidAll(vs ...linalg.Vector) {
	for _, v := range vs {
		for i, x := range v {
			v[i] = sigmoid(x)
		}
	}
}

func sigmoid(x float64) float64 {
	return 1 / (1 + math.Exp(-x))
}
